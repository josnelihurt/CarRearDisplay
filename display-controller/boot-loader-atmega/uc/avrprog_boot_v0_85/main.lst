   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 116               	sendchar:
   1:main.c        **** /*****************************************************************************
   2:main.c        **** *
   3:main.c        **** * AVRPROG compatible boot-loader
   4:main.c        **** * Version  : 0.85 (Dec. 2008)
   5:main.c        **** * Compiler : avr-gcc 4.1.2 / avr-libc 1.4.6
   6:main.c        **** * size     : depends on features and startup ( minmal features < 512 words)
   7:main.c        **** * by       : Martin Thomas, Kaiserslautern, Germany
   8:main.c        **** *            eversmith@heizung-thomas.de
   9:main.c        **** *            Additional code and improvements contributed by:
  10:main.c        **** *           - Uwe Bonnes
  11:main.c        **** *           - Bjoern Riemer
  12:main.c        **** *           - Olaf Rempel
  13:main.c        **** *
  14:main.c        **** * License  : Copyright (c) 2006-2008 M. Thomas, U. Bonnes, O. Rempel
  15:main.c        **** *            Free to use. You have to mention the copyright
  16:main.c        **** *            owners in source-code and documentation of derived
  17:main.c        **** *            work. No warranty! (Yes, you can insert the BSD
  18:main.c        **** *            license here)
  19:main.c        **** *
  20:main.c        **** * Tested with ATmega8, ATmega16, ATmega162, ATmega32, ATmega324P,
  21:main.c        **** *             ATmega644, ATmega644P, ATmega128, AT90CAN128
  22:main.c        **** *
  23:main.c        **** * - Initial versions have been based on the Butterfly bootloader-code
  24:main.c        **** *   by Atmel Corporation (Authors: BBrandal, PKastnes, ARodland, LHM)
  25:main.c        **** *
  26:main.c        **** ****************************************************************************
  27:main.c        **** *
  28:main.c        **** *  See the makefile and readme.txt for information on how to adapt 
  29:main.c        **** *  the linker-settings to the selected Boot Size (BOOTSIZE=xxxx) and 
  30:main.c        **** *  the MCU-type. Other configurations futher down in this file.
  31:main.c        **** *
  32:main.c        **** *  With BOOT_SIMPLE, minimal features and discarded int-vectors
  33:main.c        **** *  this bootloader has should fit into a a 512 word (1024, 0x400 bytes) 
  34:main.c        **** *  bootloader-section. 
  35:main.c        **** *
  36:main.c        **** ****************************************************************************/
  37:main.c        **** /*
  38:main.c        **** 	TODOs:
  39:main.c        **** 	- check lock-bits set
  40:main.c        **** 	- __bad_interrupt still linked even with modified 
  41:main.c        **** 	  linker-scripts which needs a default-handler,
  42:main.c        **** 	  "wasted": 3 words for AVR5 (>8kB), 2 words for AVR4
  43:main.c        **** 	- Check watchdog-disable-function in avr-libc.
  44:main.c        **** */
  45:main.c        **** // tabsize: 4
  46:main.c        **** 
  47:main.c        **** /* MCU frequency */
  48:main.c        **** #ifndef F_CPU
  49:main.c        **** // #define F_CPU 7372800
  50:main.c        **** #define F_CPU (12000000)
  51:main.c        **** #endif
  52:main.c        **** 
  53:main.c        **** /* UART Baudrate */
  54:main.c        ****  #define BAUDRATE 57600
  55:main.c        **** // #define BAUDRATE 19200
  56:main.c        **** //#define BAUDRATE 115200
  57:main.c        **** 
  58:main.c        **** /* use "Double Speed Operation" */
  59:main.c        **** //#define UART_DOUBLESPEED
  60:main.c        **** 
  61:main.c        **** /* use second UART on mega128 / can128 / mega162 / mega324p / mega644p */
  62:main.c        **** //#define UART_USE_SECOND
  63:main.c        **** 
  64:main.c        **** /* Device-Type:
  65:main.c        ****    For AVRProg the BOOT-option is prefered 
  66:main.c        ****    which is the "correct" value for a bootloader.
  67:main.c        ****    avrdude may only detect the part-code for ISP */
  68:main.c        **** #define DEVTYPE     DEVTYPE_BOOT
  69:main.c        **** // #define DEVTYPE     DEVTYPE_ISP
  70:main.c        **** 
  71:main.c        **** /*
  72:main.c        ****  * Pin "STARTPIN" on port "STARTPORT" in this port has to grounded
  73:main.c        ****  * (active low) to start the bootloader
  74:main.c        ****  */
  75:main.c        **** #define BLPORT		PORTC
  76:main.c        **** #define BLDDR		DDRC
  77:main.c        **** #define BLPIN		PINC
  78:main.c        **** #define BLPNUM		7
  79:main.c        **** 
  80:main.c        **** /*
  81:main.c        ****  * Define if Watchdog-Timer should be disable at startup
  82:main.c        ****  */
  83:main.c        **** #define DISABLE_WDT_AT_STARTUP
  84:main.c        **** 
  85:main.c        **** /*
  86:main.c        ****  * Watchdog-reset is issued at exit 
  87:main.c        ****  * define the timeout-value here (see avr-libc manual)
  88:main.c        ****  */
  89:main.c        **** #define EXIT_WDT_TIME   WDTO_250MS
  90:main.c        **** 
  91:main.c        **** /*
  92:main.c        ****  * Select startup-mode
  93:main.c        ****  * SIMPLE-Mode - Jump to bootloader main BL-loop if key is
  94:main.c        ****  *   pressed (Pin grounded) "during" reset or jump to the
  95:main.c        ****  *   application if the pin is not grounded. The internal
  96:main.c        ****  *   pull-up resistor is enabled during the startup and
  97:main.c        ****  *   gets disabled before the application is started.
  98:main.c        ****  * POWERSAVE-Mode - Startup is separated in two loops
  99:main.c        ****  *   which makes power-saving a little easier if no firmware
 100:main.c        ****  *   is on the chip. Needs more memory
 101:main.c        ****  * BOOTICE-Mode - to flash the JTAGICE upgrade.ebn file.
 102:main.c        ****  *   No startup-sequence in this mode. Jump directly to the
 103:main.c        ****  *   parser-loop on reset
 104:main.c        ****  *   F_CPU in BOOTICEMODE must be 7372800 Hz to be compatible
 105:main.c        ****  *   with the org. JTAGICE-Firmware
 106:main.c        ****  * WAIT-mode waits 1 sec for the defined character if nothing 
 107:main.c        ****  *    is recived then the user prog is started.
 108:main.c        ****  */
 109:main.c        **** //#define START_SIMPLE
 110:main.c        **** #define START_WAIT
 111:main.c        **** //#define START_POWERSAVE
 112:main.c        **** //#define START_BOOTICE
 113:main.c        **** 
 114:main.c        **** /* character to start the bootloader in mode START_WAIT */
 115:main.c        **** #define START_WAIT_UARTCHAR 'S'
 116:main.c        **** 
 117:main.c        **** /* wait-time for START_WAIT mode ( t = WAIT_TIME * 10ms ) */
 118:main.c        **** #define WAIT_VALUE 200 /* here: 100*10ms = 1000ms = 1sec */
 119:main.c        **** 
 120:main.c        **** /*
 121:main.c        ****  * enable/disable readout of fuse and lock-bits
 122:main.c        ****  * (AVRPROG has to detect the AVR correctly by device-code
 123:main.c        ****  * to show the correct information).
 124:main.c        ****  */
 125:main.c        **** //#define ENABLEREADFUSELOCK
 126:main.c        **** 
 127:main.c        **** /* enable/disable write of lock-bits
 128:main.c        ****  * WARNING: lock-bits can not be reseted by bootloader (as far as I know)
 129:main.c        ****  * Only protection no unprotection, "chip erase" from bootloader only
 130:main.c        ****  * clears the flash but does no real "chip erase" (this is not possible
 131:main.c        ****  * with a bootloader as far as I know)
 132:main.c        ****  * Keep this undefined!
 133:main.c        ****  */
 134:main.c        **** //#define WRITELOCKBITS
 135:main.c        **** 
 136:main.c        **** /*
 137:main.c        ****  * define the following if the bootloader should not output
 138:main.c        ****  * itself at flash read (will fake an empty boot-section)
 139:main.c        ****  */
 140:main.c        **** #define READ_PROTECT_BOOTLOADER
 141:main.c        **** 
 142:main.c        **** 
 143:main.c        **** #define VERSION_HIGH '0'
 144:main.c        **** #define VERSION_LOW  '8'
 145:main.c        **** 
 146:main.c        **** #define GET_LOCK_BITS           0x0001
 147:main.c        **** #define GET_LOW_FUSE_BITS       0x0000
 148:main.c        **** #define GET_HIGH_FUSE_BITS      0x0003
 149:main.c        **** #define GET_EXTENDED_FUSE_BITS  0x0002
 150:main.c        **** 
 151:main.c        **** 
 152:main.c        **** #ifdef UART_DOUBLESPEED
 153:main.c        **** // #define UART_CALC_BAUDRATE(baudRate) (((F_CPU*10UL) / ((baudRate) *8UL) +5)/10 -1)
 154:main.c        **** //#define UART_CALC_BAUDRATE(baudRate) ((uint32_t)((F_CPU) + ((uint32_t)baudRate * 4UL)) / ((uint32
 155:main.c        **** #else
 156:main.c        **** // #define UART_CALC_BAUDRATE(baudRate) (((F_CPU*10UL) / ((baudRate)*16UL) +5)/10 -1)
 157:main.c        **** #define UART_CALC_BAUDRATE(baudRate) ((uint32_t)((F_CPU) + ((uint32_t)baudRate * 8UL)) / ((uint32_t
 158:main.c        **** #endif
 159:main.c        **** 
 160:main.c        **** 
 161:main.c        **** #include <stdint.h>
 162:main.c        **** #include <avr/io.h>
 163:main.c        **** #include <avr/wdt.h>
 164:main.c        **** #include <avr/boot.h>
 165:main.c        **** #include <avr/pgmspace.h>
 166:main.c        **** #include <avr/eeprom.h>
 167:main.c        **** #include <avr/interrupt.h>
 168:main.c        **** #include <util/delay.h>
 169:main.c        **** 
 170:main.c        **** #include "chipdef.h"
 171:main.c        **** 
 172:main.c        **** uint8_t gBuffer[SPM_PAGESIZE];
 173:main.c        **** 
 174:main.c        **** #if defined(BOOTLOADERHASNOVECTORS)
 175:main.c        **** #warning "This Bootloader does not link interrupt vectors - see makefile"
 176:main.c        **** /* make the linker happy - it wants to see __vector_default */
 177:main.c        **** // void __vector_default(void) { ; }
 178:main.c        **** void __vector_default(void) { ; }
 179:main.c        **** #endif
 180:main.c        **** 
 181:main.c        **** static void sendchar(uint8_t data)
 182:main.c        **** {
 118               	.LM0:
 119               	.LFBB1:
 120               	/* prologue: function */
 121               	/* frame size = 0 */
 122               	/* stack size = 0 */
 123               	.L__stack_usage = 0
 124               	.L3:
 183:main.c        **** 	while (!(UART_STATUS & (1<<UART_TXREADY)));
 126               	.LM1:
 127 0000 5D9B      		sbis 0xb,5
 128 0002 00C0      		rjmp .L3
 184:main.c        **** 	UART_DATA = data;
 130               	.LM2:
 131 0004 8CB9      		out 0xc,r24
 132 0006 0895      		ret
 134               	.Lscope1:
 137               	recvchar:
 185:main.c        **** }
 186:main.c        **** 
 187:main.c        **** static uint8_t recvchar(void)
 188:main.c        **** {
 139               	.LM3:
 140               	.LFBB2:
 141               	/* prologue: function */
 142               	/* frame size = 0 */
 143               	/* stack size = 0 */
 144               	.L__stack_usage = 0
 145               	.L7:
 189:main.c        **** 	while (!(UART_STATUS & (1<<UART_RXREADY)));
 147               	.LM4:
 148 0008 5F9B      		sbis 0xb,7
 149 000a 00C0      		rjmp .L7
 190:main.c        **** 	return UART_DATA;
 151               	.LM5:
 152 000c 8CB1      		in r24,0xc
 191:main.c        **** }
 154               	.LM6:
 155 000e 0895      		ret
 157               	.Lscope2:
 160               	send_boot:
 192:main.c        **** 
 193:main.c        **** static inline void eraseFlash(void)
 194:main.c        **** {
 195:main.c        **** 	// erase only main section (bootloader protection)
 196:main.c        **** 	uint32_t addr = 0;
 197:main.c        **** 	while (APP_END > addr) {
 198:main.c        **** 		boot_page_erase(addr);		// Perform page erase
 199:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 200:main.c        **** 		addr += SPM_PAGESIZE;
 201:main.c        **** 	}
 202:main.c        **** 	boot_rww_enable();
 203:main.c        **** }
 204:main.c        **** 
 205:main.c        **** static inline void recvBuffer(pagebuf_t size)
 206:main.c        **** {
 207:main.c        **** 	pagebuf_t cnt;
 208:main.c        **** 	uint8_t *tmp = gBuffer;
 209:main.c        **** 
 210:main.c        **** 	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) {
 211:main.c        **** 		*tmp++ = (cnt < size) ? recvchar() : 0xFF;
 212:main.c        **** 	}
 213:main.c        **** }
 214:main.c        **** 
 215:main.c        **** static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
 216:main.c        **** {
 217:main.c        **** 	uint32_t pagestart = (uint32_t)waddr<<1;
 218:main.c        **** 	uint32_t baddr = pagestart;
 219:main.c        **** 	uint16_t data;
 220:main.c        **** 	uint8_t *tmp = gBuffer;
 221:main.c        **** 
 222:main.c        **** 	do {
 223:main.c        **** 		data = *tmp++;
 224:main.c        **** 		data |= *tmp++ << 8;
 225:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 226:main.c        **** 
 227:main.c        **** 		baddr += 2;			// Select next word in memory
 228:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 229:main.c        **** 	} while (size);				// Loop until all bytes written
 230:main.c        **** 
 231:main.c        **** 	boot_page_write(pagestart);
 232:main.c        **** 	boot_spm_busy_wait();
 233:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 234:main.c        **** 
 235:main.c        **** 	return baddr>>1;
 236:main.c        **** }
 237:main.c        **** 
 238:main.c        **** static inline uint16_t writeEEpromPage(uint16_t address, pagebuf_t size)
 239:main.c        **** {
 240:main.c        **** 	uint8_t *tmp = gBuffer;
 241:main.c        **** 
 242:main.c        **** 	do {
 243:main.c        **** 		eeprom_write_byte( (uint8_t*)address, *tmp++ );
 244:main.c        **** 		address++;			// Select next byte
 245:main.c        **** 		size--;				// Decreas number of bytes to write
 246:main.c        **** 	} while (size);				// Loop until all bytes written
 247:main.c        **** 
 248:main.c        **** 	// eeprom_busy_wait();
 249:main.c        **** 
 250:main.c        **** 	return address;
 251:main.c        **** }
 252:main.c        **** 
 253:main.c        **** static inline uint16_t readFlashPage(uint16_t waddr, pagebuf_t size)
 254:main.c        **** {
 255:main.c        **** 	uint32_t baddr = (uint32_t)waddr<<1;
 256:main.c        **** 	uint16_t data;
 257:main.c        **** 
 258:main.c        **** 	do {
 259:main.c        **** #ifndef READ_PROTECT_BOOTLOADER
 260:main.c        **** #warning "Bootloader not read-protected"
 261:main.c        **** #if defined(RAMPZ)
 262:main.c        **** 		data = pgm_read_word_far(baddr);
 263:main.c        **** #else
 264:main.c        **** 		data = pgm_read_word_near(baddr);
 265:main.c        **** #endif
 266:main.c        **** #else
 267:main.c        **** 		// don't read bootloader
 268:main.c        **** 		if ( baddr < APP_END ) {
 269:main.c        **** #if defined(RAMPZ)
 270:main.c        **** 			data = pgm_read_word_far(baddr);
 271:main.c        **** #else
 272:main.c        **** 			data = pgm_read_word_near(baddr);
 273:main.c        **** #endif
 274:main.c        **** 		}
 275:main.c        **** 		else {
 276:main.c        **** 			data = 0xFFFF; // fake empty
 277:main.c        **** 		}
 278:main.c        **** #endif
 279:main.c        **** 		sendchar(data);			// send LSB
 280:main.c        **** 		sendchar((data >> 8));		// send MSB
 281:main.c        **** 		baddr += 2;			// Select next word in memory
 282:main.c        **** 		size -= 2;			// Subtract two bytes from number of bytes to read
 283:main.c        **** 	} while (size);				// Repeat until block has been read
 284:main.c        **** 
 285:main.c        **** 	return baddr>>1;
 286:main.c        **** }
 287:main.c        **** 
 288:main.c        **** static inline uint16_t readEEpromPage(uint16_t address, pagebuf_t size)
 289:main.c        **** {
 290:main.c        **** 	do {
 291:main.c        **** 		sendchar( eeprom_read_byte( (uint8_t*)address ) );
 292:main.c        **** 		address++;
 293:main.c        **** 		size--;				// Decrease number of bytes to read
 294:main.c        **** 	} while (size);				// Repeat until block has been read
 295:main.c        **** 
 296:main.c        **** 	return address;
 297:main.c        **** }
 298:main.c        **** 
 299:main.c        **** #if defined(ENABLEREADFUSELOCK)
 300:main.c        **** static uint8_t read_fuse_lock(uint16_t addr)
 301:main.c        **** {
 302:main.c        **** 	uint8_t mode = (1<<BLBSET) | (1<<SPMEN);
 303:main.c        **** 	uint8_t retval;
 304:main.c        **** 
 305:main.c        **** 	asm volatile
 306:main.c        **** 	(
 307:main.c        **** 		"movw r30, %3\n\t"		/* Z to addr */ \
 308:main.c        **** 		"sts %0, %2\n\t"		/* set mode in SPM_REG */ \
 309:main.c        **** 		"lpm\n\t"			/* load fuse/lock value into r0 */ \
 310:main.c        **** 		"mov %1,r0\n\t"			/* save return value */ \
 311:main.c        **** 		: "=m" (SPM_REG),
 312:main.c        **** 		  "=r" (retval)
 313:main.c        **** 		: "r" (mode),
 314:main.c        **** 		  "r" (addr)
 315:main.c        **** 		: "r30", "r31", "r0"
 316:main.c        **** 	);
 317:main.c        **** 	return retval;
 318:main.c        **** }
 319:main.c        **** #endif
 320:main.c        **** 
 321:main.c        **** static void send_boot(void)
 322:main.c        **** {
 162               	.LM7:
 163               	.LFBB3:
 164               	/* prologue: function */
 165               	/* frame size = 0 */
 166               	/* stack size = 0 */
 167               	.L__stack_usage = 0
 323:main.c        **** 	sendchar('A');
 169               	.LM8:
 170 0010 81E4      		ldi r24,lo8(65)
 171 0012 00D0      		rcall sendchar
 324:main.c        **** 	sendchar('V');
 173               	.LM9:
 174 0014 86E5      		ldi r24,lo8(86)
 175 0016 00D0      		rcall sendchar
 325:main.c        **** 	sendchar('R');
 177               	.LM10:
 178 0018 82E5      		ldi r24,lo8(82)
 179 001a 00D0      		rcall sendchar
 326:main.c        **** 	sendchar('B');
 181               	.LM11:
 182 001c 82E4      		ldi r24,lo8(66)
 183 001e 00D0      		rcall sendchar
 327:main.c        **** 	sendchar('O');
 185               	.LM12:
 186 0020 8FE4      		ldi r24,lo8(79)
 187 0022 00D0      		rcall sendchar
 328:main.c        **** 	sendchar('O');
 189               	.LM13:
 190 0024 8FE4      		ldi r24,lo8(79)
 191 0026 00D0      		rcall sendchar
 329:main.c        **** 	sendchar('T');
 193               	.LM14:
 194 0028 84E5      		ldi r24,lo8(84)
 195 002a 00C0      		rjmp sendchar
 197               	.Lscope3:
 199               	.global	__vector_default
 201               	__vector_default:
 178:main.c        **** void __vector_default(void) { ; }
 203               	.LM15:
 204               	.LFBB4:
 205               	/* prologue: function */
 206               	/* frame size = 0 */
 207               	/* stack size = 0 */
 208               	.L__stack_usage = 0
 209 002c 0895      		ret
 211               	.Lscope4:
 212               		.section	.text.startup,"ax",@progbits
 214               	.global	main
 216               	main:
 330:main.c        **** }
 331:main.c        **** 
 332:main.c        **** static void (*jump_to_app)(void) = 0x0000;
 333:main.c        **** 
 334:main.c        **** int main(void)
 335:main.c        **** {
 218               	.LM16:
 219               	.LFBB5:
 221               	.LM17:
 222 0000 CF93      		push r28
 223 0002 DF93      		push r29
 224 0004 1F92      		push __zero_reg__
 225 0006 CDB7      		in r28,__SP_L__
 226 0008 DEB7      		in r29,__SP_H__
 227               	/* prologue: function */
 228               	/* frame size = 1 */
 229               	/* stack size = 3 */
 230               	.L__stack_usage = 3
 336:main.c        **** 	uint16_t address = 0;
 337:main.c        **** 	uint8_t device = 0, val;
 338:main.c        **** 
 339:main.c        **** #ifdef DISABLE_WDT_AT_STARTUP
 340:main.c        **** #ifdef WDT_OFF_SPECIAL
 341:main.c        **** #warning "using target specific watchdog_off"
 342:main.c        **** 	bootloader_wdt_off();
 343:main.c        **** #else
 344:main.c        **** 	cli();
 232               	.LM18:
 233               	/* #APP */
 234               	 ;  344 "main.c" 1
 235 000a F894      		cli
 236               	 ;  0 "" 2
 345:main.c        **** 	wdt_reset();
 238               	.LM19:
 239               	 ;  345 "main.c" 1
 240 000c A895      		wdr
 241               	 ;  0 "" 2
 346:main.c        **** 	wdt_disable();
 243               	.LM20:
 244               	/* #NOAPP */
 245 000e 88E1      		ldi r24,lo8(24)
 246               	/* #APP */
 247               	 ;  346 "main.c" 1
 248 0010 0FB6      		in __tmp_reg__, __SREG__
 249 0012 F894      		cli
 250 0014 81BD      		out 33, r24
 251 0016 11BC      		out 33, __zero_reg__
 252 0018 0FBE      		out __SREG__,__tmp_reg__
 253               		
 254               	 ;  0 "" 2
 347:main.c        **** #endif
 348:main.c        **** #endif
 349:main.c        **** 	
 350:main.c        **** #ifdef START_POWERSAVE
 351:main.c        **** 	uint8_t OK = 1;
 352:main.c        **** #endif
 353:main.c        **** 
 354:main.c        **** 	BLDDR  &= ~(1<<BLPNUM);		// set as Input
 256               	.LM21:
 257               	/* #NOAPP */
 258 001a A798      		cbi 0x14,7
 355:main.c        **** 	BLPORT |= (1<<BLPNUM);		// Enable pullup
 260               	.LM22:
 261 001c AF9A      		sbi 0x15,7
 356:main.c        **** 
 357:main.c        **** 	// Set baud rate
 358:main.c        **** 	UART_BAUD_HIGH = (UART_CALC_BAUDRATE(BAUDRATE)>>8) & 0xFF;
 263               	.LM23:
 264 001e 10BC      		out 0x20,__zero_reg__
 359:main.c        **** 	UART_BAUD_LOW = (UART_CALC_BAUDRATE(BAUDRATE) & 0xFF);
 266               	.LM24:
 267 0020 8CE0      		ldi r24,lo8(12)
 268 0022 89B9      		out 0x9,r24
 360:main.c        **** 
 361:main.c        **** #ifdef UART_DOUBLESPEED
 362:main.c        **** 	UART_STATUS = ( 1<<UART_DOUBLE );
 363:main.c        **** #endif
 364:main.c        **** 
 365:main.c        **** 	UART_CTRL = UART_CTRL_DATA;
 270               	.LM25:
 271 0024 88E1      		ldi r24,lo8(24)
 272 0026 8AB9      		out 0xa,r24
 366:main.c        **** 	UART_CTRL2 = UART_CTRL2_DATA;
 274               	.LM26:
 275 0028 86E8      		ldi r24,lo8(-122)
 276 002a 80BD      		out 0x20,r24
 367:main.c        **** 	
 368:main.c        **** 	send_boot();
 278               	.LM27:
 279 002c 00D0      		rcall send_boot
 280 002e E12C      		mov r14,__zero_reg__
 281 0030 F12C      		mov r15,__zero_reg__
 369:main.c        **** #if defined(START_POWERSAVE)
 370:main.c        **** 	/*
 371:main.c        **** 		This is an adoption of the Butterfly Bootloader startup-sequence.
 372:main.c        **** 		It may look a little strange but separating the login-loop from
 373:main.c        **** 		the main parser-loop gives a lot a possibilities (timeout, sleep-modes
 374:main.c        **** 	    etc.).
 375:main.c        **** 	*/
 376:main.c        **** 	for(;OK;) 
 377:main.c        **** 	{
 378:main.c        **** 		if ((BLPIN & (1<<BLPNUM))) {
 379:main.c        **** 			// jump to main app if pin is not grounded
 380:main.c        **** 			BLPORT &= ~(1<<BLPNUM);	// set to default
 381:main.c        **** #ifdef UART_DOUBLESPEED
 382:main.c        **** 			UART_STATUS &= ~( 1<<UART_DOUBLE );
 383:main.c        **** #endif
 384:main.c        **** 			jump_to_app();		// Jump to application sector
 385:main.c        **** 		} 
 386:main.c        **** 		else 
 387:main.c        **** 		{
 388:main.c        **** 				val = recvchar();
 389:main.c        **** 				/* ESC */
 390:main.c        **** 				if (val == 0x1B) 
 391:main.c        **** 				{
 392:main.c        **** 					// AVRPROG connection
 393:main.c        **** 					// Wait for signon
 394:main.c        **** 					while (val != 'S')
 395:main.c        **** 						val = recvchar();
 396:main.c        **** 
 397:main.c        **** 					send_boot();			// Report signon
 398:main.c        **** 					OK = 0;
 399:main.c        **** 
 400:main.c        **** 				} 
 401:main.c        **** 				else 
 402:main.c        **** 				{
 403:main.c        **** 					sendchar('?');
 404:main.c        **** 				}
 405:main.c        **** 		}
 406:main.c        **** 		// Power-Save code here
 407:main.c        **** 	}
 408:main.c        **** 
 409:main.c        **** #elif defined(START_SIMPLE)
 410:main.c        **** 
 411:main.c        **** 	if ((BLPIN & (1<<BLPNUM))) {
 412:main.c        **** 		// jump to main app if pin is not grounded
 413:main.c        **** 		BLPORT &= ~(1<<BLPNUM);		// set to default		
 414:main.c        **** #ifdef UART_DOUBLESPEED
 415:main.c        **** 		UART_STATUS &= ~( 1<<UART_DOUBLE );
 416:main.c        **** #endif
 417:main.c        **** 		jump_to_app();			// Jump to application sector
 418:main.c        **** 	}
 419:main.c        **** 
 420:main.c        **** #elif defined(START_WAIT)
 421:main.c        **** 
 422:main.c        **** 	uint16_t cnt = 0;
 423:main.c        **** 
 424:main.c        **** 	while (1) {
 425:main.c        **** 		if (UART_STATUS & (1<<UART_RXREADY))
 426:main.c        **** 			if (UART_DATA == START_WAIT_UARTCHAR)
 427:main.c        **** 				break;
 428:main.c        **** 
 429:main.c        **** 		if (cnt++ >= WAIT_VALUE) {
 430:main.c        **** 			BLPORT &= ~(1<<BLPNUM);		// set to default
 431:main.c        **** 			jump_to_app();			// Jump to application sector
 283               	.LM28:
 284 0032 00E0      		ldi r16,0
 285 0034 10E0      		ldi r17,0
 286               	.L14:
 425:main.c        **** 		if (UART_STATUS & (1<<UART_RXREADY))
 288               	.LM29:
 289 0036 5F9B      		sbis 0xb,7
 290 0038 00C0      		rjmp .L11
 426:main.c        **** 			if (UART_DATA == START_WAIT_UARTCHAR)
 292               	.LM30:
 293 003a 8CB1      		in r24,0xc
 294 003c 8335      		cpi r24,lo8(83)
 295 003e 01F0      		breq .L12
 296               	.L11:
 429:main.c        **** 		if (cnt++ >= WAIT_VALUE) {
 298               	.LM31:
 299 0040 88EC      		ldi r24,-56
 300 0042 E816      		cp r14,r24
 301 0044 F104      		cpc r15,__zero_reg__
 302 0046 00F0      		brlo .L13
 430:main.c        **** 			BLPORT &= ~(1<<BLPNUM);		// set to default
 304               	.LM32:
 305 0048 AF98      		cbi 0x15,7
 307               	.LM33:
 308 004a F801      		movw r30,r16
 309 004c 0995      		icall
 310               	.L13:
 311               	.LBB23:
 312               	.LBB24:
 314               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 316               	.LM34:
 317 004e 8FE2      		ldi r24,lo8(29999)
 318 0050 95E7      		ldi r25,hi8(29999)
 319 0052 0197      		1: sbiw r24,1
 320 0054 01F4      		brne 1b
 321 0056 00C0      		rjmp .
 322 0058 0000      		nop
 323 005a 9FEF      		ldi r25,-1
 324 005c E91A      		sub r14,r25
 325 005e F90A      		sbc r15,r25
 326 0060 00C0      		rjmp .L14
 327               	.L12:
 328               	.LBE24:
 329               	.LBE23:
 331               	.Ltext2:
 432:main.c        **** 		}
 433:main.c        **** 
 434:main.c        **** 		_delay_ms(10);
 435:main.c        **** 	}
 436:main.c        **** 	send_boot();
 333               	.LM35:
 334 0062 00D0      		rcall send_boot
 337:main.c        **** 	uint8_t device = 0, val;
 336               	.LM36:
 337 0064 812C      		mov r8,__zero_reg__
 336:main.c        **** 	uint16_t address = 0;
 339               	.LM37:
 340 0066 C12C      		mov r12,__zero_reg__
 341 0068 D12C      		mov r13,__zero_reg__
 437:main.c        **** 
 438:main.c        **** #elif defined(START_BOOTICE)
 439:main.c        **** #warning "BOOTICE mode - no startup-condition"
 440:main.c        **** 
 441:main.c        **** #else
 442:main.c        **** #error "Select START_ condition for bootloader in main.c"
 443:main.c        **** #endif
 444:main.c        **** 
 445:main.c        **** 	for(;;) {
 446:main.c        **** 		val = recvchar();
 447:main.c        **** 		// Autoincrement?
 448:main.c        **** 		if (val == 'a') {
 449:main.c        **** 			sendchar('Y');			// Autoincrement is quicker
 450:main.c        **** 
 451:main.c        **** 		//write address
 452:main.c        **** 		} else if (val == 'A') {
 453:main.c        **** 			address = recvchar();		//read address 8 MSB
 454:main.c        **** 			address = (address<<8) | recvchar();
 455:main.c        **** 			sendchar('\r');
 456:main.c        **** 
 457:main.c        **** 		// Buffer load support
 458:main.c        **** 		} else if (val == 'b') {
 459:main.c        **** 			sendchar('Y');					// Report buffer load supported
 460:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 461:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 462:main.c        **** 
 463:main.c        **** 		// Start buffer load
 464:main.c        **** 		} else if (val == 'B') {
 465:main.c        **** 			pagebuf_t size;
 466:main.c        **** 			size = recvchar() << 8;				// Load high byte of buffersize
 467:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 468:main.c        **** 			val = recvchar();				// Load memory type ('E' or 'F')
 469:main.c        **** 			recvBuffer(size);
 470:main.c        **** 
 471:main.c        **** 			if (device == DEVTYPE) {
 472:main.c        **** 				if (val == 'F') {
 473:main.c        **** 					address = writeFlashPage(address, size);
 474:main.c        **** 				} else if (val == 'E') {
 475:main.c        **** 					address = writeEEpromPage(address, size);
 476:main.c        **** 				}
 477:main.c        **** 				sendchar('\r');
 478:main.c        **** 			} else {
 479:main.c        **** 				sendchar(0);
 480:main.c        **** 			}
 481:main.c        **** 
 482:main.c        **** 		// Block read
 483:main.c        **** 		} else if (val == 'g') {
 484:main.c        **** 			pagebuf_t size;
 485:main.c        **** 			size = recvchar() << 8;				// Load high byte of buffersize
 486:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 487:main.c        **** 			val = recvchar();				// Get memtype
 488:main.c        **** 
 489:main.c        **** 			if (val == 'F') {
 490:main.c        **** 				address = readFlashPage(address, size);
 491:main.c        **** 			} else if (val == 'E') {
 492:main.c        **** 				address = readEEpromPage(address, size);
 493:main.c        **** 			}
 494:main.c        **** 
 495:main.c        **** 		// Chip erase
 496:main.c        ****  		} else if (val == 'e') {
 497:main.c        **** 			if (device == DEVTYPE) {
 498:main.c        **** 				eraseFlash();
 499:main.c        **** 			}
 500:main.c        **** 			sendchar('\r');
 501:main.c        **** 
 502:main.c        **** 		// Exit upgrade
 503:main.c        **** 		} else if (val == 'E') {
 504:main.c        **** 			wdt_enable(EXIT_WDT_TIME); // Enable Watchdog Timer to give reset
 343               	.LM38:
 344 006a 6CE0      		ldi r22,lo8(12)
 345 006c 362E      		mov r3,r22
 346               	.LBB25:
 347               	.LBB26:
 198:main.c        **** 		boot_page_erase(addr);		// Perform page erase
 349               	.LM39:
 350 006e 73E0      		ldi r23,lo8(3)
 351 0070 672E      		mov r6,r23
 202:main.c        **** 	boot_rww_enable();
 353               	.LM40:
 354 0072 E1E1      		ldi r30,lo8(17)
 355 0074 7E2E      		mov r7,r30
 356               	.LBE26:
 357               	.LBE25:
 358               	.LBB28:
 359               	.LBB29:
 360               	.LBB30:
 225:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 362               	.LM41:
 363 0076 5524      		clr r5
 364 0078 5394      		inc r5
 231:main.c        **** 	boot_page_write(pagestart);
 366               	.LM42:
 367 007a F5E0      		ldi r31,lo8(5)
 368 007c 4F2E      		mov r4,r31
 369               	.L15:
 370               	.LBE30:
 371               	.LBE29:
 372               	.LBE28:
 446:main.c        **** 		val = recvchar();
 374               	.LM43:
 375 007e 00D0      		rcall recvchar
 448:main.c        **** 		if (val == 'a') {
 377               	.LM44:
 378 0080 8136      		cpi r24,lo8(97)
 379 0082 01F4      		brne .L16
 449:main.c        **** 			sendchar('Y');			// Autoincrement is quicker
 381               	.LM45:
 382 0084 89E5      		ldi r24,lo8(89)
 383 0086 00C0      		rjmp .L61
 384               	.L16:
 452:main.c        **** 		} else if (val == 'A') {
 386               	.LM46:
 387 0088 8134      		cpi r24,lo8(65)
 388 008a 01F4      		brne .L18
 453:main.c        **** 			address = recvchar();		//read address 8 MSB
 390               	.LM47:
 391 008c 00D0      		rcall recvchar
 392 008e 90E0      		ldi r25,0
 454:main.c        **** 			address = (address<<8) | recvchar();
 394               	.LM48:
 395 0090 D82E      		mov r13,r24
 396 0092 CC24      		clr r12
 397 0094 00D0      		rcall recvchar
 398 0096 C82A      		or r12,r24
 399 0098 00C0      		rjmp .L62
 400               	.L18:
 458:main.c        **** 		} else if (val == 'b') {
 402               	.LM49:
 403 009a 8236      		cpi r24,lo8(98)
 404 009c 01F4      		brne .L19
 459:main.c        **** 			sendchar('Y');					// Report buffer load supported
 406               	.LM50:
 407 009e 89E5      		ldi r24,lo8(89)
 408 00a0 00D0      		rcall sendchar
 460:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 410               	.LM51:
 411 00a2 80E0      		ldi r24,0
 412 00a4 00D0      		rcall sendchar
 461:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 414               	.LM52:
 415 00a6 80E4      		ldi r24,lo8(64)
 416 00a8 00C0      		rjmp .L61
 417               	.L19:
 464:main.c        **** 		} else if (val == 'B') {
 419               	.LM53:
 420 00aa 8234      		cpi r24,lo8(66)
 421 00ac 01F0      		breq .+2
 422 00ae 00C0      		rjmp .L20
 423               	.LBB37:
 466:main.c        **** 			size = recvchar() << 8;				// Load high byte of buffersize
 425               	.LM54:
 426 00b0 00D0      		rcall recvchar
 467:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 428               	.LM55:
 429 00b2 00D0      		rcall recvchar
 430 00b4 982E      		mov r9,r24
 468:main.c        **** 			val = recvchar();				// Load memory type ('E' or 'F')
 432               	.LM56:
 433 00b6 00D0      		rcall recvchar
 434 00b8 982F      		mov r25,r24
 435 00ba 00E0      		ldi r16,lo8(gBuffer)
 436 00bc 10E0      		ldi r17,hi8(gBuffer)
 437               	.LBB32:
 438               	.LBB33:
 210:main.c        **** 	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) {
 440               	.LM57:
 441 00be B12C      		mov r11,__zero_reg__
 442               	.L23:
 211:main.c        **** 		*tmp++ = (cnt < size) ? recvchar() : 0xFF;
 444               	.LM58:
 445 00c0 B914      		cp r11,r9
 446 00c2 00F4      		brsh .L56
 447 00c4 9983      		std Y+1,r25
 448 00c6 00D0      		rcall recvchar
 449 00c8 9981      		ldd r25,Y+1
 450 00ca 00C0      		rjmp .L21
 451               	.L56:
 452 00cc 8FEF      		ldi r24,lo8(-1)
 453               	.L21:
 454 00ce F801      		movw r30,r16
 455 00d0 8193      		st Z+,r24
 456 00d2 8F01      		movw r16,r30
 210:main.c        **** 	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) {
 458               	.LM59:
 459 00d4 B394      		inc r11
 460 00d6 F0E4      		ldi r31,lo8(64)
 461 00d8 BF12      		cpse r11,r31
 462 00da 00C0      		rjmp .L23
 463               	.LBE33:
 464               	.LBE32:
 471:main.c        **** 			if (device == DEVTYPE) {
 466               	.LM60:
 467 00dc 87E7      		ldi r24,lo8(119)
 468 00de 8812      		cpse r8,r24
 469 00e0 00C0      		rjmp .L63
 472:main.c        **** 				if (val == 'F') {
 471               	.LM61:
 472 00e2 9634      		cpi r25,lo8(70)
 473 00e4 01F0      		breq .+2
 474 00e6 00C0      		rjmp .L25
 475               	.LBB34:
 476               	.LBB31:
 217:main.c        **** 	uint32_t pagestart = (uint32_t)waddr<<1;
 478               	.LM62:
 479 00e8 8601      		movw r16,r12
 480 00ea 20E0      		ldi r18,0
 481 00ec 30E0      		ldi r19,0
 482 00ee 000F      		lsl r16
 483 00f0 111F      		rol r17
 484 00f2 221F      		rol r18
 485 00f4 331F      		rol r19
 220:main.c        **** 	uint8_t *tmp = gBuffer;
 487               	.LM63:
 488 00f6 A0E0      		ldi r26,lo8(gBuffer)
 489 00f8 B0E0      		ldi r27,hi8(gBuffer)
 490 00fa 8091 0000 		lds r24,gBuffer
 218:main.c        **** 	uint32_t baddr = pagestart;
 492               	.LM64:
 493 00fe B901      		movw r22,r18
 494 0100 A801      		movw r20,r16
 495 0102 900E      		add r9,r16
 496               	.L27:
 224:main.c        **** 		data |= *tmp++ << 8;
 498               	.LM65:
 499 0104 1196      		adiw r26,1
 500 0106 EC91      		ld r30,X
 501 0108 1197      		sbiw r26,1
 502 010a 90E0      		ldi r25,0
 503 010c 9E2B      		or r25,r30
 225:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 505               	.LM66:
 506 010e FA01      		movw r30,r20
 507               	/* #APP */
 508               	 ;  225 "main.c" 1
 509 0110 0C01      		movw  r0, r24
 510 0112 5092 5700 		sts 87, r5
 511 0116 E895      		spm
 512 0118 1124      		clr  r1
 513               		
 514               	 ;  0 "" 2
 227:main.c        **** 		baddr += 2;			// Select next word in memory
 516               	.LM67:
 517               	/* #NOAPP */
 518 011a 4E5F      		subi r20,-2
 519 011c 5F4F      		sbci r21,-1
 520 011e 6F4F      		sbci r22,-1
 521 0120 7F4F      		sbci r23,-1
 229:main.c        **** 	} while (size);				// Loop until all bytes written
 523               	.LM68:
 524 0122 9416      		cp r9,r20
 525 0124 01F0      		breq .L26
 224:main.c        **** 		data |= *tmp++ << 8;
 527               	.LM69:
 528 0126 1296      		adiw r26,2
 529 0128 8C91      		ld r24,X
 530 012a 1297      		sbiw r26,2
 531 012c 1296      		adiw r26,2
 532 012e 00C0      		rjmp .L27
 533               	.L26:
 231:main.c        **** 	boot_page_write(pagestart);
 535               	.LM70:
 536 0130 F801      		movw r30,r16
 537               	/* #APP */
 538               	 ;  231 "main.c" 1
 539 0132 4092 5700 		sts 87, r4
 540 0136 E895      		spm
 541               		
 542               	 ;  0 "" 2
 543               	/* #NOAPP */
 544               	.L29:
 232:main.c        **** 	boot_spm_busy_wait();
 546               	.LM71:
 547 0138 07B6      		in __tmp_reg__,0x37
 548 013a 00FC      		sbrc __tmp_reg__,0
 549 013c 00C0      		rjmp .L29
 233:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 551               	.LM72:
 552               	/* #APP */
 553               	 ;  233 "main.c" 1
 554 013e 7092 5700 		sts 87, r7
 555 0142 E895      		spm
 556               		
 557               	 ;  0 "" 2
 235:main.c        **** 	return baddr>>1;
 559               	.LM73:
 560               	/* #NOAPP */
 561 0144 7695      		lsr r23
 562 0146 6795      		ror r22
 563 0148 5795      		ror r21
 564 014a 4795      		ror r20
 565 014c 6A01      		movw r12,r20
 566               	.LBE31:
 567               	.LBE34:
 568 014e 00C0      		rjmp .L62
 569               	.L25:
 474:main.c        **** 				} else if (val == 'E') {
 571               	.LM74:
 572 0150 9534      		cpi r25,lo8(69)
 573 0152 01F0      		breq .+2
 574 0154 00C0      		rjmp .L62
 575 0156 00E0      		ldi r16,lo8(gBuffer)
 576 0158 10E0      		ldi r17,hi8(gBuffer)
 577 015a C601      		movw r24,r12
 578 015c 8050      		subi r24,lo8(gBuffer)
 579 015e 9040      		sbci r25,hi8(gBuffer)
 580 0160 5C01      		movw r10,r24
 581 0162 F801      		movw r30,r16
 582 0164 E90D      		add r30,r9
 583 0166 2E2E      		mov r2,r30
 584               	.L32:
 585 0168 C501      		movw r24,r10
 586 016a 800F      		add r24,r16
 587 016c 911F      		adc r25,r17
 588               	.LBB35:
 589               	.LBB36:
 243:main.c        **** 		eeprom_write_byte( (uint8_t*)address, *tmp++ );
 591               	.LM75:
 592 016e F801      		movw r30,r16
 593 0170 6191      		ld r22,Z+
 594 0172 8F01      		movw r16,r30
 595 0174 00D0      		rcall __eewr_byte_m8
 246:main.c        **** 	} while (size);				// Loop until all bytes written
 597               	.LM76:
 598 0176 2012      		cpse r2,r16
 599 0178 00C0      		rjmp .L32
 600 017a FFEF      		ldi r31,-1
 601 017c CF1A      		sub r12,r31
 602 017e DF0A      		sbc r13,r31
 603 0180 9A94      		dec r9
 604 0182 C90C      		add r12,r9
 605 0184 D11C      		adc r13,__zero_reg__
 606 0186 00C0      		rjmp .L62
 607               	.L20:
 608               	.LBE36:
 609               	.LBE35:
 610               	.LBE37:
 483:main.c        **** 		} else if (val == 'g') {
 612               	.LM77:
 613 0188 8736      		cpi r24,lo8(103)
 614 018a 01F0      		breq .+2
 615 018c 00C0      		rjmp .L33
 616               	.LBB38:
 485:main.c        **** 			size = recvchar() << 8;				// Load high byte of buffersize
 618               	.LM78:
 619 018e 00D0      		rcall recvchar
 486:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 621               	.LM79:
 622 0190 00D0      		rcall recvchar
 623 0192 B82E      		mov r11,r24
 487:main.c        **** 			val = recvchar();				// Get memtype
 625               	.LM80:
 626 0194 00D0      		rcall recvchar
 489:main.c        **** 			if (val == 'F') {
 628               	.LM81:
 629 0196 8634      		cpi r24,lo8(70)
 630 0198 01F4      		brne .L34
 631               	.LBB39:
 632               	.LBB40:
 255:main.c        **** 	uint32_t baddr = (uint32_t)waddr<<1;
 634               	.LM82:
 635 019a E12C      		mov r14,__zero_reg__
 636 019c F12C      		mov r15,__zero_reg__
 637 019e CC0C      		lsl r12
 638 01a0 DD1C      		rol r13
 639 01a2 EE1C      		rol r14
 640 01a4 FF1C      		rol r15
 641 01a6 BC0C      		add r11,r12
 642               	.L37:
 268:main.c        **** 		if ( baddr < APP_END ) {
 644               	.LM83:
 645 01a8 8FEF      		ldi r24,-1
 646 01aa C816      		cp r12,r24
 647 01ac 8BE1      		ldi r24,27
 648 01ae D806      		cpc r13,r24
 649 01b0 E104      		cpc r14,__zero_reg__
 650 01b2 F104      		cpc r15,__zero_reg__
 651 01b4 00F4      		brsh .L57
 652               	.LBB41:
 272:main.c        **** 			data = pgm_read_word_near(baddr);
 654               	.LM84:
 655 01b6 F601      		movw r30,r12
 656               	/* #APP */
 657               	 ;  272 "main.c" 1
 658 01b8 2591      		lpm r18, Z+
 659 01ba 3491      		lpm r19, Z
 660               		
 661               	 ;  0 "" 2
 662               	/* #NOAPP */
 663 01bc 822F      		mov r24,r18
 664 01be 132F      		mov r17,r19
 665 01c0 00C0      		rjmp .L35
 666               	.L57:
 667               	.LBE41:
 276:main.c        **** 			data = 0xFFFF; // fake empty
 669               	.LM85:
 670 01c2 8FEF      		ldi r24,lo8(-1)
 671 01c4 1FEF      		ldi r17,lo8(-1)
 672               	.L35:
 279:main.c        **** 		sendchar(data);			// send LSB
 674               	.LM86:
 675 01c6 00D0      		rcall sendchar
 280:main.c        **** 		sendchar((data >> 8));		// send MSB
 677               	.LM87:
 678 01c8 812F      		mov r24,r17
 679 01ca 00D0      		rcall sendchar
 281:main.c        **** 		baddr += 2;			// Select next word in memory
 681               	.LM88:
 682 01cc 92E0      		ldi r25,2
 683 01ce C90E      		add r12,r25
 684 01d0 D11C      		adc r13,__zero_reg__
 685 01d2 E11C      		adc r14,__zero_reg__
 686 01d4 F11C      		adc r15,__zero_reg__
 283:main.c        **** 	} while (size);				// Repeat until block has been read
 688               	.LM89:
 689 01d6 BC10      		cpse r11,r12
 690 01d8 00C0      		rjmp .L37
 285:main.c        **** 	return baddr>>1;
 692               	.LM90:
 693 01da B701      		movw r22,r14
 694 01dc A601      		movw r20,r12
 695 01de 7695      		lsr r23
 696 01e0 6795      		ror r22
 697 01e2 5795      		ror r21
 698 01e4 4795      		ror r20
 699 01e6 6A01      		movw r12,r20
 700               	.LBE40:
 701               	.LBE39:
 702 01e8 00C0      		rjmp .L15
 703               	.L34:
 491:main.c        **** 			} else if (val == 'E') {
 705               	.LM91:
 706 01ea 8534      		cpi r24,lo8(69)
 707 01ec 01F0      		breq .+2
 708 01ee 00C0      		rjmp .L15
 709 01f0 8601      		movw r16,r12
 710 01f2 AC2C      		mov r10,r12
 711 01f4 AB0C      		add r10,r11
 712               	.L39:
 713               	.LBB42:
 714               	.LBB43:
 291:main.c        **** 		sendchar( eeprom_read_byte( (uint8_t*)address ) );
 716               	.LM92:
 717 01f6 C801      		movw r24,r16
 718 01f8 00D0      		rcall __eerd_byte_m8
 719 01fa 00D0      		rcall sendchar
 292:main.c        **** 		address++;
 721               	.LM93:
 722 01fc 0F5F      		subi r16,-1
 723 01fe 1F4F      		sbci r17,-1
 294:main.c        **** 	} while (size);				// Repeat until block has been read
 725               	.LM94:
 726 0200 A012      		cpse r10,r16
 727 0202 00C0      		rjmp .L39
 728 0204 EFEF      		ldi r30,-1
 729 0206 CE1A      		sub r12,r30
 730 0208 DE0A      		sbc r13,r30
 731 020a BA94      		dec r11
 732 020c CB0C      		add r12,r11
 733 020e D11C      		adc r13,__zero_reg__
 734 0210 00C0      		rjmp .L15
 735               	.L33:
 736               	.LBE43:
 737               	.LBE42:
 738               	.LBE38:
 496:main.c        ****  		} else if (val == 'e') {
 740               	.LM95:
 741 0212 8536      		cpi r24,lo8(101)
 742 0214 01F4      		brne .L40
 497:main.c        **** 			if (device == DEVTYPE) {
 744               	.LM96:
 745 0216 F7E7      		ldi r31,lo8(119)
 746 0218 8F12      		cpse r8,r31
 747 021a 00C0      		rjmp .L62
 748 021c E0E0      		ldi r30,0
 749 021e F0E0      		ldi r31,0
 750               	.L45:
 751               	.LBB44:
 752               	.LBB27:
 198:main.c        **** 		boot_page_erase(addr);		// Perform page erase
 754               	.LM97:
 755               	/* #APP */
 756               	 ;  198 "main.c" 1
 757 0220 6092 5700 		sts 87, r6
 758 0224 E895      		spm
 759               		
 760               	 ;  0 "" 2
 761               	/* #NOAPP */
 762               	.L43:
 199:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 764               	.LM98:
 765 0226 07B6      		in __tmp_reg__,0x37
 766 0228 00FC      		sbrc __tmp_reg__,0
 767 022a 00C0      		rjmp .L43
 768 022c E05C      		subi r30,-64
 769 022e FF4F      		sbci r31,-1
 197:main.c        **** 	while (APP_END > addr) {
 771               	.LM99:
 772 0230 E115      		cp r30,__zero_reg__
 773 0232 8CE1      		ldi r24,28
 774 0234 F807      		cpc r31,r24
 775 0236 01F4      		brne .L45
 202:main.c        **** 	boot_rww_enable();
 777               	.LM100:
 778               	/* #APP */
 779               	 ;  202 "main.c" 1
 780 0238 7092 5700 		sts 87, r7
 781 023c E895      		spm
 782               		
 783               	 ;  0 "" 2
 784               	/* #NOAPP */
 785 023e 00C0      		rjmp .L62
 786               	.L40:
 787               	.LBE27:
 788               	.LBE44:
 503:main.c        **** 		} else if (val == 'E') {
 790               	.LM101:
 791 0240 8534      		cpi r24,lo8(69)
 792 0242 01F4      		brne .L46
 794               	.LM102:
 795 0244 E8E1      		ldi r30,lo8(24)
 796 0246 F0E0      		ldi r31,0
 797               	/* #APP */
 798               	 ;  504 "main.c" 1
 799 0248 0FB6      		in __tmp_reg__,__SREG__
 800 024a F894      		cli
 801 024c A895      		wdr
 802 024e E1BD      		out 33,r30
 803 0250 0FBE      		out __SREG__,__tmp_reg__
 804 0252 31BC      		out 33,r3
 805               	 ;  0 "" 2
 806               	/* #NOAPP */
 807 0254 00C0      		rjmp .L62
 808               	.L46:
 505:main.c        **** 			sendchar('\r');
 506:main.c        **** 
 507:main.c        **** #ifdef WRITELOCKBITS
 508:main.c        **** #warning "Extension 'WriteLockBits' enabled"
 509:main.c        **** 		// TODO: does not work reliably
 510:main.c        **** 		// write lockbits
 511:main.c        **** 		} else if (val == 'l') {
 512:main.c        **** 			if (device == DEVTYPE) {
 513:main.c        **** 				// write_lock_bits(recvchar());
 514:main.c        **** 				boot_lock_bits_set(recvchar());	// boot.h takes care of mask
 515:main.c        **** 				boot_spm_busy_wait();
 516:main.c        **** 			}
 517:main.c        **** 			sendchar('\r');
 518:main.c        **** #endif
 519:main.c        **** 		// Enter programming mode
 520:main.c        **** 		} else if (val == 'P') {
 810               	.LM103:
 811 0256 8035      		cpi r24,lo8(80)
 812 0258 01F0      		breq .L62
 521:main.c        **** 			sendchar('\r');
 522:main.c        **** 
 523:main.c        **** 		// Leave programming mode
 524:main.c        **** 		} else if (val == 'L') {
 814               	.LM104:
 815 025a 8C34      		cpi r24,lo8(76)
 816 025c 01F0      		breq .L62
 525:main.c        **** 			sendchar('\r');
 526:main.c        **** 
 527:main.c        **** 		// return programmer type
 528:main.c        **** 		} else if (val == 'p') {
 818               	.LM105:
 819 025e 8037      		cpi r24,lo8(112)
 820 0260 01F4      		brne .L49
 529:main.c        **** 			sendchar('S');		// always serial programmer
 822               	.LM106:
 823 0262 83E5      		ldi r24,lo8(83)
 824 0264 00C0      		rjmp .L61
 825               	.L49:
 530:main.c        **** 
 531:main.c        **** #ifdef ENABLEREADFUSELOCK
 532:main.c        **** #warning "Extension 'ReadFuseLock' enabled"
 533:main.c        **** 		// read "low" fuse bits
 534:main.c        **** 		} else if (val == 'F') {
 535:main.c        **** 			sendchar(read_fuse_lock(GET_LOW_FUSE_BITS));
 536:main.c        **** 
 537:main.c        **** 		// read lock bits
 538:main.c        **** 		} else if (val == 'r') {
 539:main.c        **** 			sendchar(read_fuse_lock(GET_LOCK_BITS));
 540:main.c        **** 
 541:main.c        **** 		// read high fuse bits
 542:main.c        **** 		} else if (val == 'N') {
 543:main.c        **** 			sendchar(read_fuse_lock(GET_HIGH_FUSE_BITS));
 544:main.c        **** 
 545:main.c        **** 		// read extended fuse bits
 546:main.c        **** 		} else if (val == 'Q') {
 547:main.c        **** 			sendchar(read_fuse_lock(GET_EXTENDED_FUSE_BITS));
 548:main.c        **** #endif
 549:main.c        **** 
 550:main.c        **** 		// Return device type
 551:main.c        **** 		} else if (val == 't') {
 827               	.LM107:
 828 0266 8437      		cpi r24,lo8(116)
 829 0268 01F4      		brne .L50
 552:main.c        **** 			sendchar(DEVTYPE);
 831               	.LM108:
 832 026a 87E7      		ldi r24,lo8(119)
 833 026c 00D0      		rcall sendchar
 834               	.L63:
 553:main.c        **** 			sendchar(0);
 836               	.LM109:
 837 026e 80E0      		ldi r24,0
 838 0270 00C0      		rjmp .L61
 839               	.L50:
 554:main.c        **** 
 555:main.c        **** 		// clear and set LED ignored
 556:main.c        **** 		} else if ((val == 'x') || (val == 'y')) {
 841               	.LM110:
 842 0272 98E8      		ldi r25,lo8(-120)
 843 0274 980F      		add r25,r24
 844 0276 9230      		cpi r25,lo8(2)
 845 0278 00F4      		brsh .L51
 557:main.c        **** 			recvchar();
 847               	.LM111:
 848 027a 00D0      		rcall recvchar
 849 027c 00C0      		rjmp .L62
 850               	.L51:
 558:main.c        **** 			sendchar('\r');
 559:main.c        **** 
 560:main.c        **** 		// set device
 561:main.c        **** 		} else if (val == 'T') {
 852               	.LM112:
 853 027e 8435      		cpi r24,lo8(84)
 854 0280 01F4      		brne .L52
 562:main.c        **** 			device = recvchar();
 856               	.LM113:
 857 0282 00D0      		rcall recvchar
 858 0284 882E      		mov r8,r24
 859               	.L62:
 563:main.c        **** 			sendchar('\r');
 861               	.LM114:
 862 0286 8DE0      		ldi r24,lo8(13)
 863 0288 00C0      		rjmp .L61
 864               	.L52:
 564:main.c        **** 
 565:main.c        **** 		// Return software identifier
 566:main.c        **** 		} else if (val == 'S') {
 866               	.LM115:
 867 028a 8335      		cpi r24,lo8(83)
 868 028c 01F4      		brne .L53
 567:main.c        **** 			send_boot();
 870               	.LM116:
 871 028e 00D0      		rcall send_boot
 872 0290 00C0      		rjmp .L15
 873               	.L53:
 568:main.c        **** 
 569:main.c        **** 		// Return Software Version
 570:main.c        **** 		} else if (val == 'V') {
 875               	.LM117:
 876 0292 8635      		cpi r24,lo8(86)
 877 0294 01F4      		brne .L54
 571:main.c        **** 			sendchar(VERSION_HIGH);
 879               	.LM118:
 880 0296 80E3      		ldi r24,lo8(48)
 881 0298 00D0      		rcall sendchar
 572:main.c        **** 			sendchar(VERSION_LOW);
 883               	.LM119:
 884 029a 88E3      		ldi r24,lo8(56)
 885 029c 00C0      		rjmp .L61
 886               	.L54:
 573:main.c        **** 
 574:main.c        **** 		// Return Signature Bytes (it seems that 
 575:main.c        **** 		// AVRProg expects the "Atmel-byte" 0x1E last
 576:main.c        **** 		// but shows it first in the dialog-window)
 577:main.c        **** 		} else if (val == 's') {
 888               	.LM120:
 889 029e 8337      		cpi r24,lo8(115)
 890 02a0 01F4      		brne .L55
 578:main.c        **** 			sendchar(SIG_BYTE3);
 892               	.LM121:
 893 02a2 87E0      		ldi r24,lo8(7)
 894 02a4 00D0      		rcall sendchar
 579:main.c        **** 			sendchar(SIG_BYTE2);
 896               	.LM122:
 897 02a6 83E9      		ldi r24,lo8(-109)
 898 02a8 00D0      		rcall sendchar
 580:main.c        **** 			sendchar(SIG_BYTE1);
 900               	.LM123:
 901 02aa 8EE1      		ldi r24,lo8(30)
 902 02ac 00C0      		rjmp .L61
 903               	.L55:
 581:main.c        **** 
 582:main.c        **** 		/* ESC */
 583:main.c        **** 		} else if(val != 0x1b) {
 905               	.LM124:
 906 02ae 8B31      		cpi r24,lo8(27)
 907 02b0 01F4      		brne .+2
 908 02b2 00C0      		rjmp .L15
 584:main.c        **** 			sendchar('?');
 910               	.LM125:
 911 02b4 8FE3      		ldi r24,lo8(63)
 912               	.L61:
 913 02b6 00D0      		rcall sendchar
 914 02b8 00C0      		rjmp .L15
 928               	.Lscope5:
 929               		.comm	gBuffer,64,1
 931               		.text
 933               	.Letext0:
 934               		.ident	"GCC: (GNU) 4.8.2"
 935               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccXU0bd1.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccXU0bd1.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccXU0bd1.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccXU0bd1.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccXU0bd1.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccXU0bd1.s:116    .text:0000000000000000 sendchar
     /tmp/ccXU0bd1.s:137    .text:0000000000000008 recvchar
     /tmp/ccXU0bd1.s:160    .text:0000000000000010 send_boot
     /tmp/ccXU0bd1.s:201    .text:000000000000002c __vector_default
     /tmp/ccXU0bd1.s:216    .text.startup:0000000000000000 main
                            *COM*:0000000000000040 gBuffer

UNDEFINED SYMBOLS
__eewr_byte_m8
__eerd_byte_m8
__do_clear_bss
